---
title: "Laravelのルーティングをしっかり理解する"
date: 2022-06-14T17:01:35+09:00
draft: true
---

ルーティングはWebアプリケーションを作る上でほぼ必須の機能であり、またLaravelの数々の機能の中で特別に大きな機能ではありません。そのため、私はしっかり理解せずに、なんとなくで使っていました。

しかし実は、機能の中心となる`Route`ファサードが備えるメソッドは40以上と数あるファサードの中でもトップクラスに多い上、そのほとんどはチェーンして使うことになるため、意外と複雑です。

この記事では、そもそもルーティングとはなにかを考えるところから始めて、Laravelのルート設定のパターンをしっかり把握した上で、具体的な設定機能を紹介する、という流れで説明していきます。


## 基本的な使い方

まずは基本的な使い方を簡単に紹介します。ルートは、デフォルトでは`routes/web.php`に設定します。設定には`Route`ファサードを使います。

一番単純な設定方法では、HTTPメソッドと同じ名前のメソッドを使い、URL(パス)のパターンと、そのパスにアクセスされた場合に行う処理をそれぞれ引数として設定します。

また、以下のように、メソッドチェーンでつなげて`name()`メソッドを呼び出すこともよく行われます。これにより、ルートに名前がつけられ、後でその名前からURLを生成することができます。

```php
<?php

use App\Http\Controllers\UserController;

// GETで/user/createにアクセスされた場合に、App\Http\Controllers\UserControllerのcreateメソッドを実行する
Route::get('user/create', [UserController::class, 'create'])->name('users.create');

// POSTで/userにアクセスされた場合に……
Route::post('user', [UserController::class, 'store'])->name('users.store');

// GETで/user/1などにアクセスされた場合に……
Route::get('user/{user}', [UserController::class, 'show'])->name('users.show');
```

単純なCRUDを実装する場合には、`resource()`でリソースルートを設定することもできます。CRUDに対応した複数のルート[^crud]を簡単に、一括で登録できます。

`only()`や`except()`で必要なルートのみ設定したり、不要なルートを除外することもできます。

```php
<?php

use App\Http\Controllers\UserController;

Route::resource('user', UserController::class)->only(['create', 'store', 'show']);
```

複数のルートをグループとしてまとめて設定することもできます。グループ内で設定する各ルートにパスや名前の共通のプレフィックスを指定したり、共通のミドルウェアを指定したりできます。

```php
<?php

use App\Http\Controllers\UserController;

Route::prefix('user')->name('users.')->group(function () {
  Route::get('create', [UserController::class, 'create'])->name('create');
  Route::post('', [UserController::class, 'store'])->name('store');
  Route::get('{user}', [UserController::class, 'show'])->name('show');
});
```

上記の3つのサンプルコードは、すべてまったく同じルートを設定します。


## ルーティングとはなにか

よりよく理解するために、まずルーティングとはなにか、ということについて考えます。

元々Webアプリケーションでは、1URLが1ファイルで、1ファイルが1つの機能という形が一般的でした。

```
/users/create.php
/users/store.php
/users/show.php?id=1
```

あるいは以下のように、クエリストリングで追加の制御をしていました。

```
/users.php?action=create
/users.php?action=store
/users.php?action=show&id=1
```

このような形の実装の場合、エントリポイントとなる各PHPファイルのすべてで共通の処理を書く必要があり、不便です。またなにより、URLの見た目が悪い[^ugly-url]です。

このような問題を回避するために、エントリポイントを1つだけにし、そのエントリポイントに擬似的なパス情報を渡し、それにより指定された機能を実行するというパターンがルーティングです。

```
/users/create
/users
/users/1
```

ルーティングが具体的に行うのは、URL(パス)とアプリケーション内部の機能をつなぐことです。そのために、アプリケーションはパスと機能の対応表を持ちます。Laravelのルーティングにおいては、この対応の一つが「ルート」として扱われます。

単純に固定のパスと機能の対応だけでは同じように扱いたいいくつかのリソースがある場合に不便なため、パスの一部をパラメータとして扱うこともよく行われます。Laravelでももちろん可能です。

```php
<?php

use App\Http\Controllers\UserController;

Route::get('user/{user}/edit', [UserController::class, 'edit'])->name('users.edit');
```

たとえば上記のコードでは、`/user/1/edit`や`/user/2/edit`のような一定のパターンのパスを、指定した機能と対応させます。

これにより、いくつかのリソースに対して同じ処理を行いたい場合にリソースごとにルートを設定しなくてよいため便利です。

また、パスのパターンとパラメータから逆にパスを生成することもできます。Laravelではこの場合、ルートに名前をつける必要があります。

```php
<?php

// $userを編集するためのパスが生成される
// $user->id == 1であれば、https://.../users/1/editとなる
echo route('users.edit', $user);
```

ルーティングとは、パス、あるいはパスのパターンとアプリケーション内部の機能を対応させるものと考えてよさそうです。Laravelでは、ルートの設定だけしておけば、リクエストごとに自動で適切なルートを選択し、またルートと対応した機能を呼び出してくれます。

ちなみにフレームワークによっては、規定のパスのパターンがあり、それに沿った機能を実行するような形のルーティングもあります。

Laravelのルートとして無理矢理表現するなら、`/{controller}/{action}`のようなパターンで、`controller`に対応する名前のコントローラの、`action`に対応する名前のメソッドを自動で呼び出すようなものです。

ルートを設定しなくてよいのがメリットで、URLを自由に設計できないのがデメリットでしょうか。このような規定のルートと、任意に設定できるルートのハイブリッドになっているものもあります。


## ルートはアプリケーションにどう登録されるか、そしてどうマッチングされるか

次は、 [基本的な使い方](#基本的な使い方) で提示したような形でルートを設定したときに、どうアプリケーションに登録されるのか、またその後リクエストの処理時に対応するルートがどう選択されるのか、その流れを見ていきます。


### どう登録されるか

ルートはアプリケーションにどう登録されるのでしょうか。ルートは`routes/web.php`に設定するため、どこかのタイミングでこのファイルが読み込まれているはずです。が、実はLaravelのソースコードを追っても、その処理はありません。

`routes/web.php`を読み込んでいるのはアプリケーション側、`App\Services\RouteServiceProvider`の処理です。ここで`routes()`メソッドで、どのようにルートを設定するかをコールバック関数で登録しています。コールバック関数はアプリケーションのブート後のタイミングで実行されます。

そして、`Route`ファサードの各メソッドで設定されたルートは、シングルトンの`router`サービスに保持されます。


### どうマッチングされるか

routerサービスに保持されたルートは、どのように選択されるのでしょうか。

まずそもそも、ルーティングはHTTPカーネルの機能です。LaravelにはHTTPとコンソールの、2つのカーネルがありますが、このうちHTTPカーネルでのみルーティングが処理されます。

そもそもルーティングとは、リクエストされたパスとアプリケーション内部の機能をつなぐものでした。ですので、リクエストがないコンソールカーネルでルーティングされないのは考えれば当たり前のことです。

ルーティングは、HTTPカーネルの核心となる機能です。HTTPカーネルはサービスとして生成し、`handle()`メソッドを実行するという流れで使用しますが、この`handle()`内の処理の最後でルーティングが行われます。実際に実行されるのは、`Illuminate\Routing\Router::dispatch`メソッドです。

<!-- コラム: routes/console.phpはルートではない -->


## ルーティングに関連するクラスを把握する

ここまでの流れでルーティングについて大まかな理解はできたと思います。詳細な機能の説明に入る前にもう一点だけ、ルーティングに関連する主要なクラスについての理解を深めたいと思います。

`Route`ファサードによるルートの設定方法には、大きく分けて3つありました。HTTPメソッドと同じ名前のメソッド等によるもの、`resource()`メソッドによるもの、`group()`メソッドのコールバックとして渡して一括で登録するものです。

これら3つをそれぞれ別に説明したことには理由がありました。この3パターンでは、内部的な処理の流れがそれぞれまったく違うためです。まず、処理のために使用されるクラスが違います。

HTTPメソッド名のメソッドから登録する場合、`Router::get()`等はすべて一つのメソッド、`Router::addRoute()`を呼び出しています。ここで新たにルート(`Illuminate\Routing\Route`)を生成した上でルートコレクション(`Illuminate\Routing\RouteCollection`)に登録し、さらに戻り値として返しています。

つまり、`Router::get()`等からチェーンして続くメソッドは、すべて`\Illuminate\Routing\Route`のメソッドとなります。`name()`や`where()`が特によく使われるかと思います。

`Router::resource()`は`Illuminate\Routing\PendingResourceRegistration`というクラスのインスタンスを返します。これは名前通り、リソースルートの登録を「保留」する特殊なクラスです。

なぜ保留にしておくかというと、`resource()`からは`only()`や`expect()`, `middleware()`等にチェーンできますが、`resource()`の実行時点でルートを生成・登録する場合、後に続くメソッドで行う処理が、すでにルートコレクションに登録されたルートの登録を解除したり、追加で登録したり、その`resource()`で登録したものだけにミドルウェアを設定したりと、煩雑になるためでしょう。

保留しているものは、デストラクタの実行時に登録されるようになっています。


* group()は戻り値はない。コールバックを渡す。逆に、チェーンしてgroup()に続く、事前の設定がある。prefix()やname()これらは、Routerにはない(prefixはあるが、protectedだ)。ではどこにあるか？　Routerの__call()を見ると、Routerに存在しないメソッドのうち一部の例外を除いたものは、RouteRegistrarというクラスの新規インスタンスを作って委譲しているのがわかる。これはルート登録をサポートするクラスで、ルートは生成せず、先にルートの設定を受け取って保持した上で、後でルートやグループを設定できるようにしている。Route::get()->name()ではなく、Route::name()->get()が実現できるのも、Route::name()がこのクラスのインスタンスを返すためだ。この機構の詳細はやや複雑だが、どうやっているのかを理解するだけなら簡単だろう。
* 整理すると、get(), post()等から、即ルートが作成・登録され、ルート自体が返って来て、それに設定をしていく、という流れが一つ。
* resource()から、PendingResourceRegistrationを受け取って、それに設定していって、デストラクタ実行時に登録される流れが一つ。
* 先にname()やprefix(), あるいはmiddleware()を呼び出して、返されるRouteRegistrarに設定していき、最後にgroup()なり、単体のget()やpost()などを実行すると、それまでの設定でルートが生成・登録される流れが一つ。
* これらを理解していれば、ルーティングはマスターしたも同然。


## ルーティングに関係する機能を把握する

ここまでの流れで、全体像としてはどう把握すればいいか理解できているはず。ここからは、具体的な機能を確認していく。


### ルートの設定

#### ルートが持つ属性

### リソースルート

### ルートグループ

### リダイレクトルート、ビュールート

### フォールバックルート

### 現在のルートの確認

### ルーティングのパフォーマンス

### ルーティングのデバッグ

* ルートの設定で複雑なバグが出ることはまれだが、マッチングの項で書いたように、初心者は同じパスのパターンの複数ルートがあるときに混乱するかもしれない。
* また、自分で設定したルートはともかく、外部パッケージのどこか奥の方で設定されたルートを把握するのは、簡単ではない。


{{< license >}}


[^crud]: 具体的にどのようなルートが設定されるかはこちら [コントローラ 9.x Laravel#リソースコントローラにより処理されるアクション](https://readouble.com/laravel/9.x/ja/controllers.html#actions-handled-by-resource-controller)

[^ugly-url]: 個人的には単純な「見た目」以上に、拡張子がリソースのコンテントタイプを表しておらず、内部的にしか意味のない、システムで実行されるファイルを表したものになっていることが気になります。

