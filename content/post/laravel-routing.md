---
title: "Laravelのルーティングをしっかり理解する"
date: 2022-06-14T17:01:35+09:00
draft: true
---

ルーティングはWebアプリケーションを作る上でほぼ必須の機能であり、またLaravelの数々の機能の中で特別に大きな機能ではありません。そのため、私はしっかり理解せずに、なんとなくで使っていました。

しかし実は、機能の中心となる`Route`ファサードが備えるメソッドは40以上と数あるファサードの中でもトップクラスに多い上、そのほとんどはチェーンして使うことになるため、意外と複雑です。

この記事では、そもそもルーティングとはなにかを考えるところから始めて、Laravelのルート設定のパターンをしっかり把握した上で、具体的な設定機能を紹介する、という流れで説明していきます。


## 基本的な使い方

まずは基本的な使い方を簡単に紹介します。ルートは、デフォルトでは`routes/web.php`に設定します。設定には`Route`ファサードを使います。

一番単純な設定方法では、HTTPメソッドと同じ名前のメソッドを使い、URL(パス)のパターンと、そのパスにアクセスされた場合に行う処理をそれぞれ引数として設定します。

また、以下のように、メソッドチェーンでつなげて`name()`メソッドを呼び出すこともよく行われます。これにより、ルートに名前がつけられ、後でその名前からURLを生成することができます。

```php
<?php

use App\Http\Controllers\UserController;

// GETで/user/createにアクセスされた場合に、App\Http\Controllers\UserControllerのcreateメソッドを実行する
Route::get('user/create', [UserController::class, 'create'])->name('users.create');

// POSTで/userにアクセスされた場合に……
Route::post('user', [UserController::class, 'store'])->name('users.store');

// GETで/user/1などにアクセスされた場合に……
Route::get('user/{user}', [UserController::class, 'show'])->name('users.show');
```

単純なCRUDを実装する場合には、`resource()`でリソースルートを設定することもできます。CRUDに対応した複数のルート[^crud]を簡単に、一括で登録できます。

`only()`や`except()`で必要なルートのみ設定したり、不要なルートを除外することもできます。

```php
<?php

use App\Http\Controllers\UserController;

Route::resource('user', UserController::class)->only(['create', 'store', 'show']);
```

複数のルートをグループとしてまとめて設定することもできます。グループ内で設定する各ルートにパスや名前の共通のプレフィックスを指定したり、共通のミドルウェアを指定したりできます。

```php
<?php

use App\Http\Controllers\UserController;

Route::prefix('user')->name('users.')->group(function () {
  Route::get('create', [UserController::class, 'create'])->name('create');
  Route::post('', [UserController::class, 'store'])->name('store');
  Route::get('{user}', [UserController::class, 'show'])->name('show');
});
```

上記の3つのサンプルコードは、すべてまったく同じルートを設定します。


## ルーティングとはなにか

よりよく理解するために、まずルーティングとはなにか、ということについて考えます。

元々Webアプリケーションでは、1URLが1ファイルで、1ファイルが1つの機能という形が一般的でした。

```
/users/create.php
/users/store.php
/users/show.php?id=1
```

あるいは以下のように、クエリストリングで追加の制御をしていました。

```
/users.php?action=create
/users.php?action=store
/users.php?action=show&id=1
```

このような形の実装の場合、エントリポイントとなる各PHPファイルのすべてで共通の処理を書く必要があり、不便です。またなにより、URLの見た目が悪い[^ugly-url]です。

このような問題を回避するために、エントリポイントを1つだけにし、そのエントリポイントに擬似的なパス情報を渡し、それにより指定された機能を実行するというパターンがルーティングです。

```
/users/create
/users
/users/1
```

ルーティングが具体的に行うのは、URL(パス)とアプリケーション内部の機能をつなぐことです。そのために、アプリケーションはパスと機能の対応表を持ちます。Laravelのルーティングにおいては、この対応の一つが「ルート」として扱われます。

単純に固定のパスと機能の対応だけでは同じように扱いたいいくつかのリソースがある場合に不便なため、パスの一部をパラメータとして扱うこともよく行われます。Laravelでももちろん可能です。

```php
<?php

use App\Http\Controllers\UserController;

Route::get('user/{user}/edit', [UserController::class, 'edit'])->name('users.edit');
```

たとえば上記のコードでは、`/user/1/edit`や`/user/2/edit`のような一定のパターンのパスを、指定した機能と対応させます。

これにより、いくつかのリソースに対して同じ処理を行いたい場合にリソースごとにルートを設定しなくてよいため便利です。

また、パスのパターンとパラメータから逆にパスを生成することもできます。Laravelではこの場合、ルートに名前をつける必要があります。

```php
<?php

// $userを編集するためのパスが生成される
// $user->id == 1であれば、https://.../users/1/editとなる
echo route('users.edit', $user);
```

ルーティングとは、パス、あるいはパスのパターンとアプリケーション内部の機能を対応させるものと考えてよさそうです。Laravelでは、ルートの設定だけしておけば、リクエストごとに自動で適切なルートを選択し、またルートと対応した機能を呼び出してくれます。

ちなみにフレームワークによっては、規定のパスのパターンがあり、それに沿った機能を実行するような形のルーティングもあります。

Laravelのルートとして無理矢理表現するなら、`/{controller}/{action}`のようなパターンで、`controller`に対応する名前のコントローラの、`action`に対応する名前のメソッドを自動で呼び出すようなものです。

ルートを設定しなくてよいのがメリットで、URLを自由に設計できないのがデメリットでしょうか。このような規定のルートと、任意に設定できるルートのハイブリッドになっているものもあります。


## ルートはアプリケーションにどう登録されるか、そしてどうマッチングされるか

次は、 [基本的な使い方](#基本的な使い方) で提示したような形でルートを設定したときに、どうアプリケーションに登録されるのか、またその後リクエストの処理時に対応するルートがどう選択されるのか、その流れを見ていきます。


### どう登録されるか

ルートはアプリケーションにどう登録されるのでしょうか。ルートは`routes/web.php`に設定するため、どこかのタイミングでこのファイルが読み込まれているはずです。が、実はLaravelのソースコードを追っても、その処理はありません。

`routes/web.php`を読み込んでいるのはアプリケーション側、`App\Services\RouteServiceProvider`の処理です。ここで`routes()`メソッドで、どのようにルートを設定するかをコールバック関数で登録しています。コールバック関数はアプリケーションのブート後のタイミングで実行されます。

そして、`Route`ファサードの各メソッドで設定されたルートは、シングルトンの`router`サービスに保持されます。


### どうマッチングされるか

routerサービスに保持されたルートは、どのように選択されるのでしょうか。

まずそもそも、ルーティングはHTTPカーネルの機能です。LaravelにはHTTPとコンソールの、2つのカーネルがありますが、このうちHTTPカーネルでのみルーティングが処理されます。

そもそもルーティングとは、リクエストされたパスとアプリケーション内部の機能をつなぐものでした。ですので、リクエストがないコンソールカーネルでルーティングされないのは考えれば当たり前のことです。

ルーティングは、HTTPカーネルの核心となる機能です。HTTPカーネルはサービスとして生成し、`handle()`メソッドを実行するという流れで使用しますが、この`handle()`内の処理の最後でルーティングが行われます。実際に実行されるのは、`Illuminate\Routing\Router::dispatch`メソッドです。

<!-- コラム: routes/console.phpはルートではない -->


## ルートに関連するクラスを把握する

* ここまでで、ルーティングの大まかなところは把握できたかと。
* 最後に全体をしっかり理解していくが、その前に……。
* Routeファサードから、routerサービス、そしてRouterクラスが実体。またRoutingServiceProviderで設定。
* ファサードのPHPDocなり、Routerクラスの公開メソッドなりを数えるとわかるが、Routeファサードは40以上の機能を持つ。これらをただぜんぶ覚えるのは大変だ。簡単に把握する方法はないだろうか。
* ルートの設定方法は大きく分けて3つあった。
* 3つそれぞれで戻り値が違い、戻り値を元に機能を大きく3つに分けて把握することができる。
* 重複する機能の話。
* どのパターンの設定方法で、どの属性を設定できるか、表。


## ルーティングに関係する機能を把握する

ここまでの流れで、全体像としてはどう把握すればいいか理解できているはず。ここからは、具体的な機能を確認していく。


### ルートの設定

#### ルートが持つ属性

### リソースルート

### ルートグループ

### リダイレクトルート、ビュールート

### フォールバックルート

### 現在のルートの確認

### ルーティングのパフォーマンス

### ルーティングのデバッグ

* ルートの設定で複雑なバグが出ることはまれだが、マッチングの項で書いたように、初心者は同じパスのパターンの複数ルートがあるときに混乱するかもしれない。
* また、自分で設定したルートはともかく、外部パッケージのどこか奥の方で設定されたルートを把握するのは、簡単ではない。


{{< license >}}


[^crud]: 具体的にどのようなルートが設定されるかはこちら [コントローラ 9.x Laravel#リソースコントローラにより処理されるアクション](https://readouble.com/laravel/9.x/ja/controllers.html#actions-handled-by-resource-controller)

[^ugly-url]: 個人的には単純な「見た目」以上に、拡張子がリソースのコンテントタイプを表しておらず、内部的にしか意味のない、システムで実行されるファイルを表したものになっていることが気になります。

