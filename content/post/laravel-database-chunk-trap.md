---
title: "Laravelのデータベースのchunk()の罠"
date: 2021-09-21T10:15:14+09:00
draft: false
---

## クエリビルダのchunk()は便利だが罠があるのでchunkById()を使おう

TODO: MySQL想定であること書いておく。とはいえほかのRDBMSでも大きくは変わらないは
ず。


### chunk()とはなにか

Laravelでデータベースにある大量の行を処理する場合、すべての行を一度に取得しようとすると大量のメモリが必要になります。場合によってはメモリ不足で処理自体できないかもしれません。

そのようなことを防ぐために、Laravelにクエリビルダには一定の行数ごとに取得する`chunk()`というメソッドがあります。たとえば10万行あるデータを取得する際に、1000行ごとに100回取得・処理するという感じです。

`chunk()`は便利なメソッドですが、いくつかの場合に罠があるため、代わりに`chunkById()`を使おう、というのがこの記事の主旨です。

なお、データベースのカーソル機能を使う`cursor()`[^cursor]というメソッドもありますが、この記事では取り扱いません。


### どういう罠があるのか

具体的にどういう罠があるかですが、まず公式ドキュメントにも書かれているように、取得しつつ更新する場合に、想定した行を処理できない罠があります。

[データベース：クエリビルダ 9.x Laravel](https://readouble.com/laravel/9.x/ja/queries.html#chunking-results)

もう一つ、処理対象をロックせずに処理している場合に、別のトランザクションからの更新等によって、一つ目の罠同様に想定した行を処理できなかったり、さらには同じ行を複数回処理してしまうという場合があります。

ロックすれば防げるのですが、`chunk()`を使いたいほどの大量の行の処理では、ロックしてしまうとかなり長い時間テーブルにまったく触れなくなってしまうため、意図的にロックせずに処理したいという場合もあると思います。

この2つの罠は、`chunk()`ではなく`chunkById()`を使えばほぼ回避できます。


## なぜchunkById()なら大丈夫なのか

`chunk()`では駄目で`chunkById()`であれば大丈夫なのはなぜでしょうか。まず、そもそもどうして上記のような罠が起きるかを見ていきます。

`chunk()`は一定行数ごとに取得してくれるのですが、その取得方法が、クエリビルダで渡したソート方法でソートした状態で、単純に`OFFSET`, `LIMIT`で分けて取得する、となっています。

この場合、処理の途中で取得対象となる行が変わってしまうと、ずれが生じます。

`chunkById()`の場合、`OFFSET`を使わずid, あるいは指定したカラムを基準に次のチャンクを取得するため、ロックする場合は取得しつつ処理してもずれなくなり、ロックしない場合も、複数回処理してしまうような大きな問題は防げます。

<!--
* 単純な例として、取得しつつ更新する場合、単純に更新後にフラグを落とすような動き
  をする場合がある。この場合、チャンクごとに処理されるチャンクと処理されないチャ
  ンクができるという挙動になる。
* また取得しつつ更新するわけではない場合も、並び順的に間に入る行ができたり、逆に
  間にあるはずの行がなくなると、ちょっとずれる。
* chunkById()は、id, あるいは指定したカラムを基準にする。チャンクごとに、最後に
  処理した行の基準値を持つため、取得しつつ処理する場合は完全にずれがなくなり、
  ロックしない場合も、大きな問題になる影響は防げる。
-->


### 罠1: 取得しつつ更新する場合

| id         | 1   | 2   | 3   | 4   | 5   |
| :-:        | :-: | :-: | :-: | :-: | :-: |
| 取得対象か | ○  | ×  | ○  | ×  | ○  |

上記のようなデータがある場合に、取得対象のものを2つずつ処理するとします。順当に行けば最初に1, 3を、次に5が処理されて完了となります。

しかし、1, 3を取得した後に、これらが取得対象とならなくなるような変更を行った場合はどうなるでしょうか。

| id         | 1   | 2   | 3   | 4   | 5   |
| :-:        | :-: | :-: | :-: | :-: | :-: |
| 取得対象か | ×  | ×  | ×  |× | ○  |

2回目の処理では、`OFFSET 2`, `LIMIT 2`として処理されるため、`id = 5`は取得されないまま処理全体が終了してしまいます。


### 罠2: ロックせず処理する場合

`lockForUpdate()`等でロックした上で`chunk()`を実行している場合、最初の`SELECT`の後すべての処理が終わるまで

TODO: 結局、肝はなんなのか？　そこがわからんぞ。
→肝は、chunk()のように、ある条件にマッチする集合をある並び順で区切って処理する
場合に、ロックしていないと集合が変わり、そのために区切りの位置も途中で変わる、っ
てところか？

次に、ロックせずに取得・処理する場合。

forUpdate()でロックしていれば、最初のSELECTの後、トランザクション終了まではテー
ブルごとロックされるので、ほかのトランザクションからはINSERTもUPDATEも、DELETEも
できず、安全だが～、どうこう。

外部から処理されうる、という形以外は変わらない。ので、

* 自身でやる場合同様に、フラグを倒される。あるいはフラグが真のものがDELETEされ
  る。
* 逆に途中でフラグがオンにされる。あるいはフラグが真のものがINSERTされる。

ロックせずに処理する場合、どちらにしてもある程度は許容することになる。が、ロック
しないとしても許容できない場合があるはず。たとえばこんな感じか。
→行単位で一定の安全性を確保したいような場合は割とあるのでは？　みたいな。

* 全体の処理開始時点でフラグがオフだったが、チャンク処理開始時点でオンになったも
  のが、処理される。
* 逆に、フラグがオンだったものが、チャンク処理開始時点でオフになったものは、処理
  されない。

許容できないものとしては、

* 全体の処理中ずっとフラグがオンだったものが、処理されない。
* 二度処理されるものがある。

chunk()の場合、自身で更新する場合同様に、ずっと対象でも処理されずスキップされる
パターンがまずある。
さらに自身で更新する場合にはない、二度処理されるパターンもありうる。
1 3を処理後、2が真になった場合、次は3 5が対象になるためだ。


### それでもchunk()の方が適切な場合

* chunk()の方が適切である場合はあまり考えられないので、普段からchunkById()を使う
  方が安全だと思う。

む、そっか、chunkById()はorderBy()効かないのか。

https://github.com/laravel/framework/issues/35400

順番が重要な場合は、chunk()で、ロックして、「更新しないよう気をつける」か。


## 関連メソッドについて

* ちなみにchunk()やchunkById()には同系統のメソッドがいうつかある。


### each(), eachById()

* each(), eachById()は、chunk(), chunkById()を単純にforeach ()で回すパターンのシ
  ンタックスシュガー的なメソッドで、大抵の場合こちらを使う方がきれいに書けるので
  おすすめ。ただしchunk()のシンタックスシュガーだと知らない人には、each()じゃな
  くてchunk()使うべきじゃね？　となりうるのと、コレクションのeach()との混同があ
  りうる点には注意が必要かもしれない。コレクションにはchunk()もあるが、コレク
  ションのchunk()にはコールバックを渡さないので間違えづらいかと。


### chunkMap()

* chunkMap()というものもある。これにはchunkMapById()はない。機能的に取得しつつ更
  新しないただろうが、ロックしない場合はやはりずれる。


### lazy(), lazyById(), lazyByIdDesc()

* Laravel 8から？　lazy(), lazyById()といのも増えた。PHPのジェネレータを使う形に
  なったchunk()だと思うとよさそう。LazyCollectionとして扱えるのが便利なので、こ
  ちらもよいかも。私はまだ使ってない。もちろん、chunk()系から移行する場合は、パ
  フォーマンスの計測はした方がいいかと。


## 別解

アプリケーション側でデータを処理したいからchunk()ごとに処理することになる。すべ
てデータベース側でできるなら、バルクアップデートを使えば、アプリケーション側では
ほとんどメモリを消費せず処理できる。

もちろんデータベース側でどうしてもできないこともあるが～。

あと、最初に処理対象のidだけぜんぶ取った上で処理するという方法もある。メモリは使
うし、ロックするわけじゃないので別のトランザクションから触られるのは触られるが、
ロックせずにある時点である条件にマッチする行を確実にすべて処理できる方法ではあ
る。まあ、削除には弱い。


---

[^cursor]: `cursor()`は単純にジェネレータで`PDOStatement::fetch()`しているだけのようで、実際には分割されておらずメモリ消費があまり減らなかったり、それを防ぐために設定を変えた場合は処理が終了するまで同じコネクションで別のクエリを実行できなかったり、癖が強いようなので私は使用していません。
参考: [Laravelのcursorとchunkの違いとバッファクエリの対処法 - honeplusのメモ帳](http://honeplus.blog50.fc2.com/blog-entry-219.html)


