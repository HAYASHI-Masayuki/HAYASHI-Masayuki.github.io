---
title: "Laravelのデータベースのchunk()の罠"
date: 2021-09-21T10:15:14+09:00
draft: false
---

## クエリビルダのchunk()は便利だが罠があるのでchunkById()を使おう

TODO: MySQL想定であること書いておく。とはいえほかのRDBMSでも大きくは変わらないは
ず。


### chunk()とはなにか

Laravelでデータベースにある大量の行を処理したい場合、すべての行を一度に取得する	
とメモリ不足になって処理できなかったり、遅くなってしまうため、`chunk()`や`	
cursor()`[^cursor]で分割して処理をすることになります。

* 大量の行を扱う場合に、一度にぜんぶ取得してしまうと、大量のメモリを消費してしま
  う。それを防ぐために、Laravelのクエリビルダには、chunk()というメソッドがある。
* 便利なメソッドだが、いくつかの場合に罠があるため、代わりにchunkById()を使お
  う。


### どういう罠があるのか

* どういう場合にどういう罠があるか。一つ目は公式ドキュメントにも書かれているよう
  に、取得しつつ更新する、といった挙動を取った場合に、想定した行を処理できない場
  合がある。
* もう一つは、処理対象をロックせずに処理している場合に、別のトランザクションから
  の更新によって、同様に想定した行を処理できなかったり、同じ行を複数回処理してし
  まう。
* こちらについてはロックすれば防げるのであるが、chunk()したいほど大量の行を扱う
  場合、ロックすると長時間テーブルにまったく触れなくなってしまうために、意図的に
  ロックせず処理をすることがあると思う。
* 上記2つの罠を防ぐにはchunkById()を使う。


## なぜchunkById()なら大丈夫なのか

* なぜchunkById()なら大丈夫なのか。まずはそもそもの、罠がなぜできるかについて見
  ていこう。
* chunk()は、一定行数ごとに取得して渡してくれる。その取得方法だが、メソッド
  チェーンで指定したソート方法をベースに、OFFSET, LIMITで分けて取得している。
* この場合に、途中で検索条件の対象となる行にこういう変更があると、こういうずれが
  生じる。
* 単純な例として、取得しつつ更新する場合、単純に更新後にフラグを落とすような動き
  をする場合がある。この場合、チャンクごとに処理されるチャンクと処理されないチャ
  ンクができるという挙動になる。
* また取得しつつ更新するわけではない場合も、並び順的に間に入る行ができたり、逆に
  間にあるはずの行がなくなると、ちょっとずれる。
* chunkById()は、id, あるいは指定したカラムを基準にする。チャンクごとに、最後に
  処理した行の基準値を持つため、取得しつつ処理する場合は完全にずれがなくなり、
  ロックしない場合も、大きな問題になる影響は防げる。


### 罠1: 取得しつつ更新する場合

id 1 2 3 4 5
flag t f t f t
とIDで並んでる場合、flagが真のものを2つずつ処理したとする。
この場合対象は、1 3 5だ。
順当に行けば、1, 3が最初に、次に5が処理される。
だが、1, 3を取得した後に、これらのフラグを倒した場合は？
SELECT * FROM table WHERE flag IS TRUE ORDER BY id LIMIT 2, 2のようなクエリなわ
けだ。
このとき対象の集合は5だけになり、処理対象なくなっている。


### 罠2: ロックせず処理する場合

TODO: 結局、肝はなんなのか？　そこがわからんぞ。
→肝は、chunk()のように、ある条件にマッチする集合をある並び順で区切って処理する
場合に、ロックしていないと集合が変わり、そのために区切りの位置も途中で変わる、っ
てところか？

次に、ロックせずに取得・処理する場合。

forUpdate()でロックしていれば、最初のSELECTの後、トランザクション終了まではテー
ブルごとロックされるので、ほかのトランザクションからはINSERTもUPDATEも、DELETEも
できず、安全だが～、どうこう。

外部から処理されうる、という形以外は変わらない。ので、

* 自身でやる場合同様に、フラグを倒される。あるいはフラグが真のものがDELETEされ
  る。
* 逆に途中でフラグがオンにされる。あるいはフラグが真のものがINSERTされる。

ロックせずに処理する場合、どちらにしてもある程度は許容することになる。が、ロック
しないとしても許容できない場合があるはず。たとえばこんな感じか。
→行単位で一定の安全性を確保したいような場合は割とあるのでは？　みたいな。

* 全体の処理開始時点でフラグがオフだったが、チャンク処理開始時点でオンになったも
  のが、処理される。
* 逆に、フラグがオンだったものが、チャンク処理開始時点でオフになったものは、処理
  されない。

許容できないものとしては、

* 全体の処理中ずっとフラグがオンだったものが、処理されない。
* 二度処理されるものがある。

chunk()の場合、自身で更新する場合同様に、ずっと対象でも処理されずスキップされる
パターンがまずある。
さらに自身で更新する場合にはない、二度処理されるパターンもありうる。
1 3を処理後、2が真になった場合、次は3 5が対象になるためだ。


### それでもchunk()の方が適切な場合

* chunk()の方が適切である場合はあまり考えられないので、普段からchunkById()を使う
  方が安全だと思う。

む、そっか、chunkById()はorderBy()効かないのか。

https://github.com/laravel/framework/issues/35400

順番が重要な場合は、chunk()で、ロックして、「更新しないよう気をつける」か。


## 関連メソッドについて

* ちなみにchunk()やchunkById()には同系統のメソッドがいうつかある。


### each(), eachById()

* each(), eachById()は、chunk(), chunkById()を単純にforeach ()で回すパターンのシ
  ンタックスシュガー的なメソッドで、大抵の場合こちらを使う方がきれいに書けるので
  おすすめ。ただしchunk()のシンタックスシュガーだと知らない人には、each()じゃな
  くてchunk()使うべきじゃね？　となりうるのと、コレクションのeach()との混同があ
  りうる点には注意が必要かもしれない。コレクションにはchunk()もあるが、コレク
  ションのchunk()にはコールバックを渡さないので間違えづらいかと。


### chunkMap()

* chunkMap()というものもある。これにはchunkMapById()はない。機能的に取得しつつ更
  新しないただろうが、ロックしない場合はやはりずれる。


### lazy(), lazyById(), lazyByIdDesc()

* Laravel 8から？　lazy(), lazyById()といのも増えた。PHPのジェネレータを使う形に
  なったchunk()だと思うとよさそう。LazyCollectionとして扱えるのが便利なので、こ
  ちらもよいかも。私はまだ使ってない。もちろん、chunk()系から移行する場合は、パ
  フォーマンスの計測はした方がいいかと。


## 別解

アプリケーション側でデータを処理したいからchunk()ごとに処理することになる。すべ
てデータベース側でできるなら、バルクアップデートを使えば、アプリケーション側では
ほとんどメモリを消費せず処理できる。

もちろんデータベース側でどうしてもできないこともあるが～。

あと、最初に処理対象のidだけぜんぶ取った上で処理するという方法もある。メモリは使
うし、ロックするわけじゃないので別のトランザクションから触られるのは触られるが、
ロックせずにある時点である条件にマッチする行を確実にすべて処理できる方法ではあ
る。まあ、削除には弱い。


---

[^cursor]: `cursor()`は単純にジェネレータで`PDOStatement::fetch()`しているだけの	
ようで、実際には分割されておらずメモリ消費があまり減らなかったり、それを防ぐため	
に設定を変えた場合は処理が終了するまで同じコネクションで別のクエリを実行できなかっ	
たり、癖が強いようなので私は使用していません。
参考: [Laravelのcursorとchunkの違いとバッファクエリの対処法 - honeplusのメモ帳]	
(http://honeplus.blog50.fc2.com/blog-entry-219.html)


